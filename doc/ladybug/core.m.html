<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ladybug.core API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

  <!-- highlight.js for highlighting source code. -->
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/default.min.css">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script>

  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 0.9em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    margin-left: 25%;
    max-width: 90%;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    position: fixed;
    height: 100%;
    width: 25%;
    float: left;
    padding: 30px;
    overflow-x: hidden;
    overflow-y: auto;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;

      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: auto;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }

  .desc {
    white-space: pre-wrap;
  }

  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
        position: inherit;
        float: none;
        width: auto;
    }
    #content {
      width: 95%;
      margin-left: auto;
      border-left: none;
      padding: 30px;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ladybug.core.AnalysisPeriod">AnalysisPeriod</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ladybug.core.AnalysisPeriod.__init__">__init__</a></li>
    <li class="mono"><a href="#ladybug.core.AnalysisPeriod.fromAnalysisPeriod">fromAnalysisPeriod</a></li>
    <li class="mono"><a href="#ladybug.core.AnalysisPeriod.isTimeIncluded">isTimeIncluded</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ladybug.core.DataList">DataList</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ladybug.core.DataList.average">average</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.__init__">__init__</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.append">append</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.averageMonthly">averageMonthly</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.averageMonthlyForEachHour">averageMonthlyForEachHour</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.checkInputData">checkInputData</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.duplicate">duplicate</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.extend">extend</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.filterByAnalysisPeriod">filterByAnalysisPeriod</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.filterByConditionalStatement">filterByConditionalStatement</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.filterByHOYs">filterByHOYs</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.filterByPattern">filterByPattern</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.groupDataByDay">groupDataByDay</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.groupDataByHour">groupDataByHour</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.groupDataByMonth">groupDataByMonth</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.updateDataForAnAnalysisPeriod">updateDataForAnAnalysisPeriod</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.updateDataForAnHour">updateDataForAnHour</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.updateDataForHoursOfYear">updateDataForHoursOfYear</a></li>
    <li class="mono"><a href="#ladybug.core.DataList.values">values</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ladybug.core.DateTimeLib">DateTimeLib</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ladybug.core.DateTimeLib.checkDateTime">checkDateTime</a></li>
    <li class="mono"><a href="#ladybug.core.DateTimeLib.getDayOfYear">getDayOfYear</a></li>
    <li class="mono"><a href="#ladybug.core.DateTimeLib.getHourOfYear">getHourOfYear</a></li>
    <li class="mono"><a href="#ladybug.core.DateTimeLib.getMonthDayHourAndMinute">getMonthDayHourAndMinute</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ladybug.core.LBData">LBData</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ladybug.core.LBData.__init__">__init__</a></li>
    <li class="mono"><a href="#ladybug.core.LBData.fromLBData">fromLBData</a></li>
    <li class="mono"><a href="#ladybug.core.LBData.updateValue">updateValue</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ladybug.core.LBDateTime">LBDateTime</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ladybug.core.LBDateTime.__init__">__init__</a></li>
    <li class="mono"><a href="#ladybug.core.LBDateTime.fromDateTimeString">fromDateTimeString</a></li>
    <li class="mono"><a href="#ladybug.core.LBDateTime.fromHOY">fromHOY</a></li>
    <li class="mono"><a href="#ladybug.core.LBDateTime.fromMOY">fromMOY</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ladybug.core.LBHeader">LBHeader</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ladybug.core.LBHeader.__init__">__init__</a></li>
    <li class="mono"><a href="#ladybug.core.LBHeader.duplicate">duplicate</a></li>
    <li class="mono"><a href="#ladybug.core.LBHeader.toList">toList</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ladybug.core.LBPatchData">LBPatchData</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ladybug.core.LBPatchData.__init__">__init__</a></li>
    <li class="mono"><a href="#ladybug.core.LBPatchData.fromLBData">fromLBData</a></li>
    <li class="mono"><a href="#ladybug.core.LBPatchData.updateValue">updateValue</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ladybug.core.Location">Location</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ladybug.core.Location.__init__">__init__</a></li>
    <li class="mono"><a href="#ladybug.core.Location.createFromEPString">createFromEPString</a></li>
    <li class="mono"><a href="#ladybug.core.Location.duplicate">duplicate</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ladybug.core</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core" class="source">
    <pre><code>import re
import copy
import euclid

class DateTimeLib:
    """Ladybug DateTime Libray
    This class includes useful data and methods for date and time
    """
    monthList = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
    numOfDaysEachMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    numOfDaysUntilMonth = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]
    numOfHoursUntilMonth = [24 * numOfDay for numOfDay in numOfDaysUntilMonth]

    @classmethod
    def checkDateTime(cls, month, day, hour, minute = None):
        """Checks if time combination is a valid time."""
        # check month
        if not 1 <= month <= 12:
            raise ValueError("month should be between 1-12")

        if day < 1 or day > cls.numOfDaysEachMonth[month-1]:
            raise ValueError("Number of days for %s should be \
                    between 1-%d"%(cls.monthList[month-1], cls.numOfDaysEachMonth[month-1]))

        if not 0 <= hour <= 24:
            raise ValueError("hour should be between 0.0-24.0")

        if not minute or minute == 0:
            if hour == 0 and day == 1 and month == 1:
                # last hour of the year
                month = 12
                day = 31
                hour = 24

            elif hour == 0 and day == 1:
                # The last hour of the last day of the month before
                month -= 1
                day = cls.numOfDaysEachMonth[month-1]
                hour = 24

            elif hour==0:
                # the last hour of the day before
                hour = 24
                day -= 1

        hour, minute = cls.__getHourAndMinute(hour, minute)

        return month, day, hour, minute

    @classmethod
    def getHourOfYear(cls, month, day, hour, minute = None):
        """Return hour of the year between 1 and 8760."""
        # make sure input values are correct
        month, day, hour, minute = cls.checkDateTime(month, day, hour, minute)

        # fix the end day
        JD = cls.numOfDaysUntilMonth[month-1] + int(day)
        return (JD - 1) * 24 + hour

    @classmethod
    def getDayOfYear(cls, month, day):
        """Retuen day of the year between 1 and 365"""
        # make sure input values are correct
        month, day, hour, minute = cls.checkDateTime(month, day, hour = 1)

        # fix the end day
        return cls.numOfDaysUntilMonth[month-1] + int(day)

    @classmethod
    def getMonthDayHourAndMinute(cls, hourOfYear):
        """Return month, day and hour for an hour of the year"""
        if hourOfYear == 8760: return 12, 31, 24, 0

        # find month
        for monthCount in range(12):
            if hourOfYear <= cls.numOfHoursUntilMonth[monthCount + 1]:
                month = monthCount + 1
                break

        # find day and hour
        if hourOfYear%24 == 0:
            # last hour of the day
            day = int((hourOfYear - cls.numOfHoursUntilMonth[month - 1])/24)
            hour = 24
            minute = 0
        else:
            day = int((hourOfYear - cls.numOfHoursUntilMonth[month - 1])/24) + 1
            hour = int(hourOfYear%24)
            minute = cls.__getHourAndMinute(hourOfYear)[1]

        return month, day, hour, minute

    @staticmethod
    def __getHourAndMinute(hour, minute = None):

        """Calculate and return hour and minute

            This method is mainly usefule for calculating minutes from float hours
            if minute is missing. otherwise it will only check the inputs append
            returns the checked values

            Args:
                hour: A float value between 0.0-24.0
                minutes: An integer between 0-59. Default in None

            Returns:
                hour: An interger between 0-24
                minute: An integer between 0-59
        """
        if not minute:
            minute = (hour - int(hour)) * 60

        # cast values to integer
        hour = int(hour + int(minute/60))
        minute = minute%60

        return hour, minute

# TODO: add comparison methods (largerthan, smallerthan, ...)
class LBDateTime:
    """Ladybug Date time"""
    def __init__(self, month = 1, day = 1, hour = 1, minute = None):
        self.month, self.day, self.hour, \
            self.minute = DateTimeLib.checkDateTime(month, day, hour, minute)

        self.floatHour = self.hour + self.minute/60.0
        self.DOY = DateTimeLib.getDayOfYear(self.month, self.day)
        self.HOY = DateTimeLib.getHourOfYear(self.month, self.day, self.hour, self.minute)
        self.MOY = self.HOY * 60  + self.minute # minute of the year
        self.floatHOY = self.HOY + self.minute/60.0

    @classmethod
    def fromHOY(cls, HOY):
        """Create Ladybug Datetime from an hour of the year

            Args:
                HOY: A float value between 0.0 to 8760.0
        """
        month, day, hour, minute = DateTimeLib.getMonthDayHourAndMinute(HOY)
        return cls(month, day, hour, minute)

    @classmethod
    def fromMOY(cls, MOY):
        """create Ladybug DateTime from Minute of the year"""
        HOY = MOY/60.0
        return cls.fromHOY(HOY)

    @classmethod
    def fromDateTimeString(cls, datetimeString):
        day, month, hour, minute = datetimeString \
                .replace(" at ", " ") \
                .replace(":", " ") \
                .split(" ")

        month = DateTimeLib.monthList.index(month.upper()) + 1

        return cls(month, int(day), int(hour), int(minute))

    @property
    def humanReadableHour(self):
        """Return hours and minutes in a human readable way"""
        minute = str(self.minute)
        if len(minute) == 1: minute = "0" + minute
        return "%d:%s"%(self.hour, minute)

    def __repr__(self):
        return "%d %s at %s"%( self.day, DateTimeLib.monthList[self.month-1], self.humanReadableHour)

# TODO: Add NA analysis period
class AnalysisPeriod:
    """Ladybug Analysis Period.

        A continuous analysis period between two days of the year between certain hours

        Attributes:
            stMonth: An integer between 1-12 for starting month (default = 1)
            stDay: An integer between 1-31 for starting day (default = 1).
                    Note that some months are shorter than 31 days.
            stHour: An integer between 1-24 for starting hour (default = 1)
            endMonth: An integer between 1-12 for ending month (default = 12)
            endDay: An integer between 1-31 for ending day (default = 31)
                    Note that some months are shorter than 31 days.
            endHour: An integer between 1-24 for ending hour (default = 24)
            timestep: An integer number from 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60
    """

    __validTimesteps = {1 : 60, 2 : 30, 3 : 20, 4 : 15, 5 : 12, \
        6 : 10, 10 : 6, 12 : 5, 15 : 4, 20 : 3, 30 : 2, 60 : 1}

    #TODO: handle timestep between 1-60
    def __init__(self, stMonth = 1, stDay = 1, stHour = 1, endMonth = 12,
                endDay = 31, endHour = 24, timestep = 1):

        """Init an analysis period"""

        # calculate start time and end time
        self.stTime = LBDateTime(int(stMonth), int(stDay), float(stHour))
        self.endTime = LBDateTime(int(endMonth), int(endDay), float(endHour))

        if self.stTime.hour <= self.endTime.hour:
            self.overnight = False # each segments of hours will be in a single day
        else:
            self.overnight = True

        # A reversed analysis period defines a period that starting month is after ending month
        # (e.g DEC to JUN)
        if self.stTime.HOY > self.endTime.HOY:
            self.reversed = True
        else:
            self.reversed = False

        # check time step
        if timestep not in self.__validTimesteps:
            raise ValueError("Invalid timestep. Valid values are %s"%str(self.__validTimesteps))

        # calculate time stamp
        self.timestep = timestep
        self.minuteIntervals = self.__validTimesteps[timestep]

        # calculate timestamps and hoursOfYear
        self.__timestampsData = {} # A dictionary for timedates. Key values will be minute of year
        self.__calculateTimestamps()

    @classmethod
    def fromAnalysisPeriod(cls, analysisPeriod):
        """Create and Analysis Period from an analysis period

            This method is useful to be called from inside Grasshopper or Dynamo
        """
        if not analysisPeriod:
            print "Analysis period is set to annual"
            return AnalysisPeriod()
        elif isinstance(analysisPeriod, AnalysisPeriod):
            return analysisPeriod
        elif isinstance(analysisPeriod, str):
            return cls.__fromAnalysisPeriodString(analysisPeriod)

    @classmethod
    def __fromAnalysisPeriodString(cls, analysisPeriodString):

        # %s/%s to %s/%s between %s to %s @%s
        ap = analysisPeriodString.lower() \
                        .replace(' ', '') \
                        .replace('to', ' ') \
                        .replace('/', ' ') \
                        .replace('between', ' ') \
                        .replace('@', ' ')
        try:
            stMonth, stDay, \
            endMonth, endDay, \
            stHour, endHour, timestep =  ap.split(' ')
            return cls(stMonth, stDay, stHour, endMonth, endDay, endHour, int(timestep))
        except:
           raise ValueError(analysisPeriodString + " is not a valid analysis period!")

    def __calculateTimestamps(self):
        """Return a list of Ladybug DateTime in this analysis period."""

        # calculate based on minutes
        curr = self.stTime.MOY - 60 + self.minuteIntervals

        if not self.reversed:
            while curr <= self.endTime.MOY:
                time = LBDateTime.fromMOY(curr)
                if not self.isTimeIncluded(time):
                    self.__timestampsData[time.MOY] = time
                curr += self.minuteIntervals
        else:
            while (0 <= curr <= self.endTime.MOY or self.stTime.MOY <= curr < 8760 * 60):
                time = LBDateTime.fromMOY(curr)
                if not self.isTimeIncluded(time):
                    self.__timestampsData[time.MOY] = time

                curr = (curr + self.minuteIntervals)%(8760 * 60)

    @property
    def dates(self):
        """A sorted list of dates in this analysis period"""
        # sort dictionary based on key values (minute of the year)
        sortedTimestamps = sorted(self.__timestampsData.items(), key= lambda x: x[0])
        return [timestamp[1] for timestamp in sortedTimestamps]

    @property
    def  HOYs(self):
        """A sorted list of hours of year in this analysis period"""
        return [timestamp.HOY for timestamp in self.dates]

    @property
    def  floatHOYs(self):
        """A sorted list of hours of year as float values in this analysis period"""
        return [timestamp.floatHOY for timestamp in self.dates]

    @property
    def totalNumOfHours(self):
        """Total number of hours during this analysis period"""
        return len(self.__timestampsData)/self.timestep

    @property
    def isAnnual(self):
        """Check if an analysis period is annual"""
        return True if self.totalNumOfHours == 8760 else False

    def isTimeIncluded(self, time):
        """Check if time is included in analysis period.

            Return True if time is inside this analysis period,
            otherwise return False

            Args:
                time: A LBDateTime to be tested

            Returns:
                A boolean. True if time is included in analysis period
        """
        # time filtering in Ladybug and honeybee is slightly different since start hour and end hour will be
        # applied for every day. For instance 2/20 9am to 2/22 5pm means hour between 9-17 during 20, 21 and 22 of Feb
        return time.MOY in self.__timestampsData

    def __repr__(self):
        return "%s/%s to %s/%s between %s to %s @%d"%\
            (self.stTime.month, self.stTime.day, \
             self.endTime.month, self.endTime.day, \
             self.stTime.hour, self.endTime.hour, \
             self.timestep)

class LBHeader:
    """Standard Ladybug header for lists.

        The header carries data for city,
        data type, unit, and analysis period

        Attributes:
            city: A string for the city name
            dataType: A valid Ladybug data type. Try DataType.dataTypes to see list of data types
            unit: dataType unit. If empty string it will be set based on dataType
            timestep: Data timestep "Hourly", "Daily", "Monthly", "Annual", "N/A"
            analysisPeriod: A Ladybug analysis period. (defualt: 1 Jan 1 to 31 Dec 24)
    """

    def __init__(self, city = 'unknown', dataType = 'unknown', unit = 'unknown', frequency = 'unknown', analysisPeriod = None):
        """Initiate Ladybug header for lists."""
        self.city = city
        self.dataType = dataType
        self.unit = unit
        self.frequency = frequency
        self.analysisPeriod = 'unknown' if not analysisPeriod \
                else AnalysisPeriod.fromAnalysisPeriod(analysisPeriod)

    def duplicate(self):
        return copy.deepcopy(self)

    @property
    def __key(self):
        return 'location|dataType|units|frequency|dataPeriod'

    def toList(self):
        """Return Ladybug header as a list"""
        return [
                 self.__key,
                 self.city,
                 self.dataType,
                 self.unit,
                 self.frequency,
                 self.analysisPeriod
               ]

    def __repr__(self):
        return "%s for %s during %s"%(self.dataType, self.city, self.analysisPeriod)

# TODO: write classes for latitude, longitude, etc
class Location:

    def __init__(self, city = '', country = '', latitude = '0.00', \
                longitude = '0.00', timeZone = '0.00', elevation ='0.00', \
                source = '', stationId = ''):

        self.city = str(city)
        self.country = str(country)
        self.latitude = float(latitude)
        self.longitude = float(longitude)
        self.timeZone = float(timeZone)
        self.elevation = float(elevation)
        self.source = str(source)
        self.stationId = str(stationId)

    def createFromEPString(self, EPString):
        """Create a Ladybug location from an EnergyPlus location string
            Parameters:
                EPString: Standard EP location string

            Usage:
                l = Location() #initiate location
                l.createFromEPString(EPString)
                print "LAT:%s, LON:%s"%(l.latitude, l.longitude)
        """

        try:
            self.city, self.latitude, \
            self.longitude, self.timeZone, \
            self.elevation = re.findall(r'\r*\n*([a-zA-Z0-9.:_-]*)[,|;]', \
                                    EPString, re.DOTALL)[1:]

            self.latitude = float(self.latitude)
            self.longitude = float(self.longitude)
            self.timeZone = float(self.timeZone)
            self.elevation = float(self.elevation)
        except Exception, e:
            raise Exception ("Failed to import EP string! %s"%str(e))

    def duplicate(self):
        return copy.deepcopy(self)

    @property
    def EPStyleLocationString(self):
        """Return EnergyPlus's location string"""
        return "Site:Location,\n" + \
            self.city + ',\n' + \
            str(self.latitude) +',      !Latitude\n' + \
            str(self.longitude) +',     !Longitude\n' + \
            str(self.timeZone) +',     !Time Zone\n' + \
            str(self.elevation) + ';       !Elevation'

    def __repr__(self):
        return "%s"%(self.EPStyleLocationString)

class LBData:
    """Ladybug data point"""

    # TODO: Change value to be an object from it's data type
    #       Check datatype.py for available datatypes

    def __init__(self, value, dateTime):
        self.datetime = dateTime
        self.value = value

    @classmethod
    def fromLBData(cls, data):
        assert isinstance(data, LBData), "Input is not a LBData."
        return data

    def updateValue(self, newValue):
        self.value = newValue

    def __int__(self):
        return int(self.value)

    def __float__(self):
        return float(self.value)

    def __str__(self):
        return str(self.value)

    def __eq__(self, other):
        return  self.value == float(other)

    def __ne__(self, other):
        return  self.value != float(other)

    def __lt__(self, other):
        return self.value < other

    def __gt__(self, other):
        return self.value > other

    def __le__(self, other):
        return self.value <= other

    def __ge__(self, other):
        return self.value >= other

    def __add__(self, other):
        return self.value + other

    def __sub__(self, other):
        return self.value - other

    def __mul__(self, other):
        return self.value * other

    def __floordiv__(self, other):
        return self.value // other

    def __div__(self, other):
        return self.value / other

    def __mod__(self, other):
        return self.value%other

    def __pow__(self, other):
        return self.value**other

    def __radd__(self, other):
        return self.__add__(other)

    def __rsub__(self, other):
        return other - self.value

    def __rmul__(self, other):
        return self.__mul__(other)

    def __rfloordiv__(self, other):
        return other//self.value

    def __rdiv__(self, other):
        return other/self.value

    def __rmod__(self, other):
        return other%self.value

    def __rpow__(self, other):
        return other**self.value

    def __repr__(self):
        return self.__str__()

class LBPatchData(LBData):
    """Ladybug sky patch data type"""
    def __init__(self, value, vector):
        # sky data doesn't have time
        datetime = LBDateTime()
        LBData.__init__(self, value, datetime)
        self.vector = euclid.Vector3(*vector)

class DataList:
    """Ladybug data list

        A list of ladybug data with a LBHeader
    """
    def __init__(self, data = None, header = None):
        self.__data = self.checkInputData(data)
        self.header = LBHeader() if not header else header

    def values(self, header = False):
        """Return the list of values

            Args:
                header: A boolean that indicates if values should include the headers

            Return:
                A list of values
        """
        if not header:
            return self.__data
        else:
            return self.header.toList() + self.__data

    @property
    def timeStamps(self):
        "List of time stamps for current data"
        return [value.datetime for value in self.__data]

    def checkInputData(self, data):
        """Check input data"""
        if not data: return []
        return [LBData.fromLBData(d) for d in data]

    def append(self, data):
        """Append LBData to current list"""
        self.extend([data])

    def extend(self, dataList):
        """Extend a list of LBData to the end of current list"""
        self.__data.extend(self.checkInputData(dataList))

    def duplicate(self):
        """Duplicate current data list"""
        return copy.deepcopy(self)

    @staticmethod
    def average(data):
        values = [value.value for value in data]
        return sum(values)/len(data)

    def groupDataByMonth(self, monthRange = range(1,13), userDataList = None):
        """Return a dictionary of values where values are grouped for each month

            key values are between 1-12

           Parameters:
               monthRange: A list of numbers for months. Default is 1-12
               userDataList: An optional data list of LBData to be processed

           Usage:
               epwfile = EPW("epw file address")
               monthlyValues = epwfile.dryBulbTemperature.groupValuesByMonth()
               print monthlyValues[2] # returns values for the month of March
        """
        hourlyDataByMonth = {}
        if userDataList:
            data = [LBData.fromLBData(d) for d in userDataList]
        else:
            data = self.__data

        for d in data:
            if not d.datetime.month in monthRange: continue

            if not hourlyDataByMonth.has_key(d.datetime.month): hourlyDataByMonth[d.datetime.month] = [] #create an empty list for month

            hourlyDataByMonth[d.datetime.month].append(d)

        print "Found data for months " + str(hourlyDataByMonth.keys())
        return hourlyDataByMonth

    def groupDataByDay(self, dayRange = range(1, 366), userDataList = None):
        """Return a dictionary of values where values are grouped by each day of year

            key values are between 1-365

           Parameters:
               dayRange: A list of numbers for days. Default is 1-365
               userDataList: An optional data list of LBData to be processed
           Usage:
               epwfile = EPW("epw file address")
               dailyValues = epwfile.dryBulbTemperature.groupDataByDay(range(1, 30))
               print dailyValues[2] # returns values for the second day of year
        """
        hourlyDataByDay = {}

        if userDataList:
            data = [LBData.fromLBData(d) for d in userDataList]
        else:
            data = self.__data

        for d in data:
            DOY = DateTimeLib.getDayOfYear(d.datetime.month, d.datetime.day)

            if not DOY in dayRange: continue

            if not hourlyDataByDay.has_key(DOY): hourlyDataByDay[DOY] = [] #create an empty list for month

            hourlyDataByDay[DOY].append(d)

        print "Found data for " + str(len(hourlyDataByDay.keys())) + " days."
        return hourlyDataByDay

    def groupDataByHour(self, hourRange = range(1, 25), userDataList = None):
        """Return a dictionary of values where values are grouped by each hour of day

            key values are between 1-24

           Parameters:
               hourRange: A list of numbers for hours. Default is 1-24
               userDataList: An optional data list of LBData to be processed

           Usage:
               epwfile = EPW("epw file address")
               monthlyValues = epwfile.dryBulbTemperature.groupDataByMonth([1])
               groupedHourlyData = epwfile.dryBulbTemperature.groupDataByHour(userDataList = monthlyValues[2])
               for hour, data in groupedHourlyData.items():
                   print "average temperature values for hour " + str(hour) + " during JAN is " + str(core.DataList.average(data)) + " " + DBT.header.unit
        """
        hourlyDataByHour = {}

        if userDataList:
            data = [LBData.fromLBData(d) for d in userDataList]
        else:
            data = self.__data

        for d in data:

            if not d.datetime.hour in hourRange: continue

            if not hourlyDataByHour.has_key(d.datetime.hour): hourlyDataByHour[d.datetime.hour] = [] #create an empty list for month

            hourlyDataByHour[d.datetime.hour].append(d)

        print "Found data for hours " + str(hourlyDataByHour.keys())
        return hourlyDataByHour

    # TODO: Add validity check for input values
    def updateDataForAnAnalysisPeriod(self, values, analysisPeriod = None):
        """Replace current values in data list with new set of values
            for a specific analysis period.

            Length of values should be equal to number of hours in analysis period

            Parameters:
                values: A list of values to be replaced in the file
                analysisPeriod: An analysis period for input the input values.
                    Default is set to the whole year.
        """
        if not analysisPeriod:
            analysisPeriod = AnalysisPeriod()

        # check length of data vs length of analysis period
        if len(values) != analysisPeriod.totalNumOfHours:
            raise ValueError("Length of values %d is not equal to " + \
                "number of hours in analysis period %d"%(len(values), \
                                                        analysisPeriod.totalNumOfHours))
        # get all time stamps
        timeStamps = analysisPeriod.dates

        # map timeStamps and values
        newValues = {}
        for count, value in enumerate(values):
            HOY = timeStamps[count].HOY
            newValues[HOY] = value

        # update values
        updatedCount = 0
        for counter, data in enumerate(self.__data):
            try:
                value = newValues[data.datetime.HOY]
                data.updateValue(value)
                updatedCount+=1
            except KeyError:
                pass

        # return self for chaining methods
        print "%s data are updated for %d hours."%(self.header.dataType, updatedCount)
        # return self for chaining methods
        return self

    def updateDataForHoursOfYear(self, values, hoursOfYear):
        """Replace current values in data list with new set of values
            for a list of hours of year

            Length of values should be equal to number of hours in hours of year

            Parameters:
                values: A list of values to be replaced in the file
                hoursOfYear: A list of HOY between 1 and 8760
        """
        # check length of data vs length of analysis period
        if len(values) != len(hoursOfYear):
            raise ValueError("Length of values %d is not equal to " + \
                "number of hours in analysis period %d"%(len(values), \
                                                        len(hoursOfYear)))

        # map hours and values
        newValues = {}
        for count, value in enumerate(values):
            HOY = hoursOfYear[count]
            newValues[HOY] = value

        # update values
        updatedCount = 0
        for counter, data in enumerate(self.__data):
            try:
                value = newValues[data.datetime.HOY]
                data.updateValue(value)
                updatedCount+=1
            except KeyError:
                pass

        print "%s data %s updated for %d hour%s."%(self.header.dataType, \
                'are' if len(values)>1 else 'is', updatedCount,\
                's' if len(values)>1 else '')

        # return self for chaining methods
        return self

    def updateDataForAnHour(self, value, hourOfYear):
        """Replace current value in data list with a new value
            for a specific hour of the year

            Parameters:
                value: A single value
                hoursOfYear: The hour of the year
        """
        return self.updateDataForHoursOfYear([value], [hourOfYear])

    def filterByAnalysisPeriod(self, analysisPeriod):

        """Filter the list based on an analysis period
            Parameters:
               analysis period: A Ladybug analysis period

            Return:
                A new DataList with filtered data

            Usage:
               analysisPeriod = AnalysisPeriod(2,1,1,3,31,24) #start of Feb to end of Mar
               epw = EPW("c:\ladybug\weatherdata.epw")
               DBT = epw.dryBulbTemperature
               filteredDBT = DBT.filterByAnalysisPeriod(analysisPeriod)
        """
        if not analysisPeriod or analysisPeriod.isAnnual:
            print "You need a valid analysis period to filter data."
            return self

        # There is no guarantee that data is continuous so I iterate through the
        # each data point one by one
        filteredData = [ d for d in self.__data if analysisPeriod.isTimeIncluded(d.datetime)]

        # create a new filteredData
        filteredHeader = self.header.duplicate()
        filteredHeader.analysisPeriod = analysisPeriod
        filteredDataList = DataList(filteredData, filteredHeader)

        return filteredDataList

    def filterByHOYs(self, HOYs):

        """Filter the list based on an analysis period
            Parameters:
               HOYs: A List of hours of the year [1-8760]

            Return:
                A new DataList with filtered data

            Usage:
               HOYs = range(1,48) # The first two days of the year
               epw = EPW("c:\ladybug\weatherdata.epw")
               DBT = epw.dryBulbTemperature
               filteredDBT = DBT.filterByHOYs(HOYs)
        """

        # There is no guarantee that data is continuous so I iterate through the
        # each data point one by one
        filteredData = [ d for d in self.__data if d.datetime.HOY in HOYs]

        # create a new filteredData
        filteredHeader = self.header.duplicate()
        filteredHeader.analysisPeriod = "unknown"
        filteredDataList = DataList(filteredData, filteredHeader)

        return filteredDataList

    def filterByConditionalStatement(self, statement):
        """Filter the list based on an analysis period
            Parameters:
               statement: A conditional statement as a string (e.g. x>25 and x%5==0).
                The variable should always be named as x

            Return:
                A new DataList with filtered data

            Usage:
               epw = EPW("c:\ladybug\weatherdata.epw")
               DBT = epw.dryBulbTemperature
               # filter data for when dry bulb temperature is more then 25
               filteredDBT = DBT.filterByConditionalStatement('x > 25')
               # get the list of time stamps that meet the conditional statement
               print filteredDBT.timeStamps
        """

        def checkInputStatement(statement):
            stStatement = statement.lower().replace("and", "").replace("or", "")\
                    .replace("not", "").replace("in", "").replace("is", "")

            l = [s for s in stStatement if s.isalpha()]
            if list(set(l)) != ['x']:
                statementErrorMsg = 'Invalid input statement. Statement should be a valid Python statement' + \
                    ' and the variable should be named as x'
                raise ValueError(statementErrorMsg)

        checkInputStatement(statement)

        statement = statement.replace('x', 'd.value')
        filteredData = [d for d in self.__data if eval(statement)]

        # create a new filteredData
        filteredHeader = self.header.duplicate()
        filteredHeader.analysisPeriod = 'N/A'
        filteredDataList = DataList(filteredData, filteredHeader)

        return filteredDataList

    def filterByPattern(self, patternList):
        """Filter the list based on a list of Boolean

            Length of Boolean should be equal to length of values in DataList

            Parameters:
                patternList: A list of True, False values

            Return:
                A new DataList with filtered data
        """
        # check length of data vs length of analysis period
        if len(self.values) != len(patternList):
            print len(self.values), len(patternList)
            errMsg = "Length of values %d is not equal to number of patterns %d" \
                    %(len(self.values), len(patternList))
            raise ValueError(errMsg)

        filteredData = [d for count, d in enumerate(self.__data) if patternList[count]]

        # create a new filteredData
        filteredHeader = self.header.duplicate()
        filteredHeader.analysisPeriod = 'N/A'
        filteredDataList = DataList(filteredData, filteredHeader)

        return filteredDataList

    def averageMonthly(self, userDataList = None):
        """Return a dictionary of values for average values for available months"""

        # group data for each month
        monthlyValues = self.groupDataByMonth(userDataList= userDataList)

        averageValues = dict()

        # average values for each month
        for month, values in monthlyValues.items():
            averageValues[month] = self.average(values)

        return averageValues

    def averageMonthlyForEachHour(self, userDataList = None):
        """Calculate average value for each hour during each month

            This method returns a dictionary with nested dictionaries for each hour
        """
        # get monthy values
        monthlyHourlyValues = self.groupDataByMonth(userDataList= userDataList)

        # group data for each hour in each month and collect them in a dictionary
        averagedMonthlyValuesPerHour = {}
        for month, monthlyValues in monthlyHourlyValues.items():
            if month not in averagedMonthlyValuesPerHour: averagedMonthlyValuesPerHour[month] = {}

            # group data for each hour
            groupedHourlyData = self.groupDataByHour(userDataList = monthlyValues)
            for hour, data in groupedHourlyData.items():
                averagedMonthlyValuesPerHour[month][hour] = self.average(data)

        return averagedMonthlyValuesPerHour

    def __len__(self):
        return len(self.__data)

    def __getitem__(self, key):
        return self.__data[key]

    def __setitem__(self, key, value):
        self.__data[key] = value

    def __delitem__(self, key):
        del self.__data[key]

    def __iter__(self):
        return iter(self.__data)

    # TODO: Reverse analysis period in header
    def __reversed__(self):
        return FunctionalList(reversed(self.__data))

    def __repr__(self):
        return "Ladybug.DataList#%s"%self.header.dataType
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ladybug.core.AnalysisPeriod" class="name">class <span class="ident">AnalysisPeriod</span></p>
      
  
    <div class="desc"><p>Ladybug Analysis Period.</p>
<p>A continuous analysis period between two days of the year between certain hours</p>
<p>Attributes:
    stMonth: An integer between 1-12 for starting month (default = 1)
    stDay: An integer between 1-31 for starting day (default = 1).
            Note that some months are shorter than 31 days.
    stHour: An integer between 1-24 for starting hour (default = 1)
    endMonth: An integer between 1-12 for ending month (default = 12)
    endDay: An integer between 1-31 for ending day (default = 31)
            Note that some months are shorter than 31 days.
    endHour: An integer between 1-24 for ending hour (default = 24)
    timestep: An integer number from 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.AnalysisPeriod', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.AnalysisPeriod" class="source">
    <pre><code>class AnalysisPeriod:
    """Ladybug Analysis Period.

        A continuous analysis period between two days of the year between certain hours

        Attributes:
            stMonth: An integer between 1-12 for starting month (default = 1)
            stDay: An integer between 1-31 for starting day (default = 1).
                    Note that some months are shorter than 31 days.
            stHour: An integer between 1-24 for starting hour (default = 1)
            endMonth: An integer between 1-12 for ending month (default = 12)
            endDay: An integer between 1-31 for ending day (default = 31)
                    Note that some months are shorter than 31 days.
            endHour: An integer between 1-24 for ending hour (default = 24)
            timestep: An integer number from 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60
    """

    __validTimesteps = {1 : 60, 2 : 30, 3 : 20, 4 : 15, 5 : 12, \
        6 : 10, 10 : 6, 12 : 5, 15 : 4, 20 : 3, 30 : 2, 60 : 1}

    #TODO: handle timestep between 1-60
    def __init__(self, stMonth = 1, stDay = 1, stHour = 1, endMonth = 12,
                endDay = 31, endHour = 24, timestep = 1):

        """Init an analysis period"""

        # calculate start time and end time
        self.stTime = LBDateTime(int(stMonth), int(stDay), float(stHour))
        self.endTime = LBDateTime(int(endMonth), int(endDay), float(endHour))

        if self.stTime.hour <= self.endTime.hour:
            self.overnight = False # each segments of hours will be in a single day
        else:
            self.overnight = True

        # A reversed analysis period defines a period that starting month is after ending month
        # (e.g DEC to JUN)
        if self.stTime.HOY > self.endTime.HOY:
            self.reversed = True
        else:
            self.reversed = False

        # check time step
        if timestep not in self.__validTimesteps:
            raise ValueError("Invalid timestep. Valid values are %s"%str(self.__validTimesteps))

        # calculate time stamp
        self.timestep = timestep
        self.minuteIntervals = self.__validTimesteps[timestep]

        # calculate timestamps and hoursOfYear
        self.__timestampsData = {} # A dictionary for timedates. Key values will be minute of year
        self.__calculateTimestamps()

    @classmethod
    def fromAnalysisPeriod(cls, analysisPeriod):
        """Create and Analysis Period from an analysis period

            This method is useful to be called from inside Grasshopper or Dynamo
        """
        if not analysisPeriod:
            print "Analysis period is set to annual"
            return AnalysisPeriod()
        elif isinstance(analysisPeriod, AnalysisPeriod):
            return analysisPeriod
        elif isinstance(analysisPeriod, str):
            return cls.__fromAnalysisPeriodString(analysisPeriod)

    @classmethod
    def __fromAnalysisPeriodString(cls, analysisPeriodString):

        # %s/%s to %s/%s between %s to %s @%s
        ap = analysisPeriodString.lower() \
                        .replace(' ', '') \
                        .replace('to', ' ') \
                        .replace('/', ' ') \
                        .replace('between', ' ') \
                        .replace('@', ' ')
        try:
            stMonth, stDay, \
            endMonth, endDay, \
            stHour, endHour, timestep =  ap.split(' ')
            return cls(stMonth, stDay, stHour, endMonth, endDay, endHour, int(timestep))
        except:
           raise ValueError(analysisPeriodString + " is not a valid analysis period!")

    def __calculateTimestamps(self):
        """Return a list of Ladybug DateTime in this analysis period."""

        # calculate based on minutes
        curr = self.stTime.MOY - 60 + self.minuteIntervals

        if not self.reversed:
            while curr <= self.endTime.MOY:
                time = LBDateTime.fromMOY(curr)
                if not self.isTimeIncluded(time):
                    self.__timestampsData[time.MOY] = time
                curr += self.minuteIntervals
        else:
            while (0 <= curr <= self.endTime.MOY or self.stTime.MOY <= curr < 8760 * 60):
                time = LBDateTime.fromMOY(curr)
                if not self.isTimeIncluded(time):
                    self.__timestampsData[time.MOY] = time

                curr = (curr + self.minuteIntervals)%(8760 * 60)

    @property
    def dates(self):
        """A sorted list of dates in this analysis period"""
        # sort dictionary based on key values (minute of the year)
        sortedTimestamps = sorted(self.__timestampsData.items(), key= lambda x: x[0])
        return [timestamp[1] for timestamp in sortedTimestamps]

    @property
    def  HOYs(self):
        """A sorted list of hours of year in this analysis period"""
        return [timestamp.HOY for timestamp in self.dates]

    @property
    def  floatHOYs(self):
        """A sorted list of hours of year as float values in this analysis period"""
        return [timestamp.floatHOY for timestamp in self.dates]

    @property
    def totalNumOfHours(self):
        """Total number of hours during this analysis period"""
        return len(self.__timestampsData)/self.timestep

    @property
    def isAnnual(self):
        """Check if an analysis period is annual"""
        return True if self.totalNumOfHours == 8760 else False

    def isTimeIncluded(self, time):
        """Check if time is included in analysis period.

            Return True if time is inside this analysis period,
            otherwise return False

            Args:
                time: A LBDateTime to be tested

            Returns:
                A boolean. True if time is included in analysis period
        """
        # time filtering in Ladybug and honeybee is slightly different since start hour and end hour will be
        # applied for every day. For instance 2/20 9am to 2/22 5pm means hour between 9-17 during 20, 21 and 22 of Feb
        return time.MOY in self.__timestampsData

    def __repr__(self):
        return "%s/%s to %s/%s between %s to %s @%d"%\
            (self.stTime.month, self.stTime.day, \
             self.endTime.month, self.endTime.day, \
             self.stTime.hour, self.endTime.hour, \
             self.timestep)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ladybug.core.AnalysisPeriod">AnalysisPeriod</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.HOYs" class="name">var <span class="ident">HOYs</span></p>
            

            
  
    <div class="desc"><p>A sorted list of hours of year in this analysis period</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.dates" class="name">var <span class="ident">dates</span></p>
            

            
  
    <div class="desc"><p>A sorted list of dates in this analysis period</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.endTime" class="name">var <span class="ident">endTime</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.floatHOYs" class="name">var <span class="ident">floatHOYs</span></p>
            

            
  
    <div class="desc"><p>A sorted list of hours of year as float values in this analysis period</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.isAnnual" class="name">var <span class="ident">isAnnual</span></p>
            

            
  
    <div class="desc"><p>Check if an analysis period is annual</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.minuteIntervals" class="name">var <span class="ident">minuteIntervals</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.stTime" class="name">var <span class="ident">stTime</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.timestep" class="name">var <span class="ident">timestep</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.AnalysisPeriod.totalNumOfHours" class="name">var <span class="ident">totalNumOfHours</span></p>
            

            
  
    <div class="desc"><p>Total number of hours during this analysis period</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.AnalysisPeriod.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, stMonth=1, stDay=1, stHour=1, endMonth=12, endDay=31, endHour=24, timestep=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Init an analysis period</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.AnalysisPeriod.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.AnalysisPeriod.__init__" class="source">
    <pre><code>def __init__(self, stMonth = 1, stDay = 1, stHour = 1, endMonth = 12,
            endDay = 31, endHour = 24, timestep = 1):
    """Init an analysis period"""
    # calculate start time and end time
    self.stTime = LBDateTime(int(stMonth), int(stDay), float(stHour))
    self.endTime = LBDateTime(int(endMonth), int(endDay), float(endHour))
    if self.stTime.hour <= self.endTime.hour:
        self.overnight = False # each segments of hours will be in a single day
    else:
        self.overnight = True
    # A reversed analysis period defines a period that starting month is after ending month
    # (e.g DEC to JUN)
    if self.stTime.HOY > self.endTime.HOY:
        self.reversed = True
    else:
        self.reversed = False
    # check time step
    if timestep not in self.__validTimesteps:
        raise ValueError("Invalid timestep. Valid values are %s"%str(self.__validTimesteps))
    # calculate time stamp
    self.timestep = timestep
    self.minuteIntervals = self.__validTimesteps[timestep]
    # calculate timestamps and hoursOfYear
    self.__timestampsData = {} # A dictionary for timedates. Key values will be minute of year
    self.__calculateTimestamps()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.AnalysisPeriod.fromAnalysisPeriod">
    <p>def <span class="ident">fromAnalysisPeriod</span>(</p><p>cls, analysisPeriod)</p>
    </div>
    

    
  
    <div class="desc"><p>Create and Analysis Period from an analysis period</p>
<p>This method is useful to be called from inside Grasshopper or Dynamo</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.AnalysisPeriod.fromAnalysisPeriod', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.AnalysisPeriod.fromAnalysisPeriod" class="source">
    <pre><code>@classmethod
def fromAnalysisPeriod(cls, analysisPeriod):
    """Create and Analysis Period from an analysis period
        This method is useful to be called from inside Grasshopper or Dynamo
    """
    if not analysisPeriod:
        print "Analysis period is set to annual"
        return AnalysisPeriod()
    elif isinstance(analysisPeriod, AnalysisPeriod):
        return analysisPeriod
    elif isinstance(analysisPeriod, str):
        return cls.__fromAnalysisPeriodString(analysisPeriod)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.AnalysisPeriod.isTimeIncluded">
    <p>def <span class="ident">isTimeIncluded</span>(</p><p>self, time)</p>
    </div>
    

    
  
    <div class="desc"><p>Check if time is included in analysis period.</p>
<p>Return True if time is inside this analysis period,
otherwise return False</p>
<p>Args:
    time: A LBDateTime to be tested</p>
<p>Returns:
    A boolean. True if time is included in analysis period</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.AnalysisPeriod.isTimeIncluded', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.AnalysisPeriod.isTimeIncluded" class="source">
    <pre><code>def isTimeIncluded(self, time):
    """Check if time is included in analysis period.
        Return True if time is inside this analysis period,
        otherwise return False
        Args:
            time: A LBDateTime to be tested
        Returns:
            A boolean. True if time is included in analysis period
    """
    # time filtering in Ladybug and honeybee is slightly different since start hour and end hour will be
    # applied for every day. For instance 2/20 9am to 2/22 5pm means hour between 9-17 during 20, 21 and 22 of Feb
    return time.MOY in self.__timestampsData
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ladybug.core.DataList" class="name">class <span class="ident">DataList</span></p>
      
  
    <div class="desc"><p>Ladybug data list</p>
<p>A list of ladybug data with a LBHeader</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList" class="source">
    <pre><code>class DataList:
    """Ladybug data list

        A list of ladybug data with a LBHeader
    """
    def __init__(self, data = None, header = None):
        self.__data = self.checkInputData(data)
        self.header = LBHeader() if not header else header

    def values(self, header = False):
        """Return the list of values

            Args:
                header: A boolean that indicates if values should include the headers

            Return:
                A list of values
        """
        if not header:
            return self.__data
        else:
            return self.header.toList() + self.__data

    @property
    def timeStamps(self):
        "List of time stamps for current data"
        return [value.datetime for value in self.__data]

    def checkInputData(self, data):
        """Check input data"""
        if not data: return []
        return [LBData.fromLBData(d) for d in data]

    def append(self, data):
        """Append LBData to current list"""
        self.extend([data])

    def extend(self, dataList):
        """Extend a list of LBData to the end of current list"""
        self.__data.extend(self.checkInputData(dataList))

    def duplicate(self):
        """Duplicate current data list"""
        return copy.deepcopy(self)

    @staticmethod
    def average(data):
        values = [value.value for value in data]
        return sum(values)/len(data)

    def groupDataByMonth(self, monthRange = range(1,13), userDataList = None):
        """Return a dictionary of values where values are grouped for each month

            key values are between 1-12

           Parameters:
               monthRange: A list of numbers for months. Default is 1-12
               userDataList: An optional data list of LBData to be processed

           Usage:
               epwfile = EPW("epw file address")
               monthlyValues = epwfile.dryBulbTemperature.groupValuesByMonth()
               print monthlyValues[2] # returns values for the month of March
        """
        hourlyDataByMonth = {}
        if userDataList:
            data = [LBData.fromLBData(d) for d in userDataList]
        else:
            data = self.__data

        for d in data:
            if not d.datetime.month in monthRange: continue

            if not hourlyDataByMonth.has_key(d.datetime.month): hourlyDataByMonth[d.datetime.month] = [] #create an empty list for month

            hourlyDataByMonth[d.datetime.month].append(d)

        print "Found data for months " + str(hourlyDataByMonth.keys())
        return hourlyDataByMonth

    def groupDataByDay(self, dayRange = range(1, 366), userDataList = None):
        """Return a dictionary of values where values are grouped by each day of year

            key values are between 1-365

           Parameters:
               dayRange: A list of numbers for days. Default is 1-365
               userDataList: An optional data list of LBData to be processed
           Usage:
               epwfile = EPW("epw file address")
               dailyValues = epwfile.dryBulbTemperature.groupDataByDay(range(1, 30))
               print dailyValues[2] # returns values for the second day of year
        """
        hourlyDataByDay = {}

        if userDataList:
            data = [LBData.fromLBData(d) for d in userDataList]
        else:
            data = self.__data

        for d in data:
            DOY = DateTimeLib.getDayOfYear(d.datetime.month, d.datetime.day)

            if not DOY in dayRange: continue

            if not hourlyDataByDay.has_key(DOY): hourlyDataByDay[DOY] = [] #create an empty list for month

            hourlyDataByDay[DOY].append(d)

        print "Found data for " + str(len(hourlyDataByDay.keys())) + " days."
        return hourlyDataByDay

    def groupDataByHour(self, hourRange = range(1, 25), userDataList = None):
        """Return a dictionary of values where values are grouped by each hour of day

            key values are between 1-24

           Parameters:
               hourRange: A list of numbers for hours. Default is 1-24
               userDataList: An optional data list of LBData to be processed

           Usage:
               epwfile = EPW("epw file address")
               monthlyValues = epwfile.dryBulbTemperature.groupDataByMonth([1])
               groupedHourlyData = epwfile.dryBulbTemperature.groupDataByHour(userDataList = monthlyValues[2])
               for hour, data in groupedHourlyData.items():
                   print "average temperature values for hour " + str(hour) + " during JAN is " + str(core.DataList.average(data)) + " " + DBT.header.unit
        """
        hourlyDataByHour = {}

        if userDataList:
            data = [LBData.fromLBData(d) for d in userDataList]
        else:
            data = self.__data

        for d in data:

            if not d.datetime.hour in hourRange: continue

            if not hourlyDataByHour.has_key(d.datetime.hour): hourlyDataByHour[d.datetime.hour] = [] #create an empty list for month

            hourlyDataByHour[d.datetime.hour].append(d)

        print "Found data for hours " + str(hourlyDataByHour.keys())
        return hourlyDataByHour

    # TODO: Add validity check for input values
    def updateDataForAnAnalysisPeriod(self, values, analysisPeriod = None):
        """Replace current values in data list with new set of values
            for a specific analysis period.

            Length of values should be equal to number of hours in analysis period

            Parameters:
                values: A list of values to be replaced in the file
                analysisPeriod: An analysis period for input the input values.
                    Default is set to the whole year.
        """
        if not analysisPeriod:
            analysisPeriod = AnalysisPeriod()

        # check length of data vs length of analysis period
        if len(values) != analysisPeriod.totalNumOfHours:
            raise ValueError("Length of values %d is not equal to " + \
                "number of hours in analysis period %d"%(len(values), \
                                                        analysisPeriod.totalNumOfHours))
        # get all time stamps
        timeStamps = analysisPeriod.dates

        # map timeStamps and values
        newValues = {}
        for count, value in enumerate(values):
            HOY = timeStamps[count].HOY
            newValues[HOY] = value

        # update values
        updatedCount = 0
        for counter, data in enumerate(self.__data):
            try:
                value = newValues[data.datetime.HOY]
                data.updateValue(value)
                updatedCount+=1
            except KeyError:
                pass

        # return self for chaining methods
        print "%s data are updated for %d hours."%(self.header.dataType, updatedCount)
        # return self for chaining methods
        return self

    def updateDataForHoursOfYear(self, values, hoursOfYear):
        """Replace current values in data list with new set of values
            for a list of hours of year

            Length of values should be equal to number of hours in hours of year

            Parameters:
                values: A list of values to be replaced in the file
                hoursOfYear: A list of HOY between 1 and 8760
        """
        # check length of data vs length of analysis period
        if len(values) != len(hoursOfYear):
            raise ValueError("Length of values %d is not equal to " + \
                "number of hours in analysis period %d"%(len(values), \
                                                        len(hoursOfYear)))

        # map hours and values
        newValues = {}
        for count, value in enumerate(values):
            HOY = hoursOfYear[count]
            newValues[HOY] = value

        # update values
        updatedCount = 0
        for counter, data in enumerate(self.__data):
            try:
                value = newValues[data.datetime.HOY]
                data.updateValue(value)
                updatedCount+=1
            except KeyError:
                pass

        print "%s data %s updated for %d hour%s."%(self.header.dataType, \
                'are' if len(values)>1 else 'is', updatedCount,\
                's' if len(values)>1 else '')

        # return self for chaining methods
        return self

    def updateDataForAnHour(self, value, hourOfYear):
        """Replace current value in data list with a new value
            for a specific hour of the year

            Parameters:
                value: A single value
                hoursOfYear: The hour of the year
        """
        return self.updateDataForHoursOfYear([value], [hourOfYear])

    def filterByAnalysisPeriod(self, analysisPeriod):

        """Filter the list based on an analysis period
            Parameters:
               analysis period: A Ladybug analysis period

            Return:
                A new DataList with filtered data

            Usage:
               analysisPeriod = AnalysisPeriod(2,1,1,3,31,24) #start of Feb to end of Mar
               epw = EPW("c:\ladybug\weatherdata.epw")
               DBT = epw.dryBulbTemperature
               filteredDBT = DBT.filterByAnalysisPeriod(analysisPeriod)
        """
        if not analysisPeriod or analysisPeriod.isAnnual:
            print "You need a valid analysis period to filter data."
            return self

        # There is no guarantee that data is continuous so I iterate through the
        # each data point one by one
        filteredData = [ d for d in self.__data if analysisPeriod.isTimeIncluded(d.datetime)]

        # create a new filteredData
        filteredHeader = self.header.duplicate()
        filteredHeader.analysisPeriod = analysisPeriod
        filteredDataList = DataList(filteredData, filteredHeader)

        return filteredDataList

    def filterByHOYs(self, HOYs):

        """Filter the list based on an analysis period
            Parameters:
               HOYs: A List of hours of the year [1-8760]

            Return:
                A new DataList with filtered data

            Usage:
               HOYs = range(1,48) # The first two days of the year
               epw = EPW("c:\ladybug\weatherdata.epw")
               DBT = epw.dryBulbTemperature
               filteredDBT = DBT.filterByHOYs(HOYs)
        """

        # There is no guarantee that data is continuous so I iterate through the
        # each data point one by one
        filteredData = [ d for d in self.__data if d.datetime.HOY in HOYs]

        # create a new filteredData
        filteredHeader = self.header.duplicate()
        filteredHeader.analysisPeriod = "unknown"
        filteredDataList = DataList(filteredData, filteredHeader)

        return filteredDataList

    def filterByConditionalStatement(self, statement):
        """Filter the list based on an analysis period
            Parameters:
               statement: A conditional statement as a string (e.g. x>25 and x%5==0).
                The variable should always be named as x

            Return:
                A new DataList with filtered data

            Usage:
               epw = EPW("c:\ladybug\weatherdata.epw")
               DBT = epw.dryBulbTemperature
               # filter data for when dry bulb temperature is more then 25
               filteredDBT = DBT.filterByConditionalStatement('x > 25')
               # get the list of time stamps that meet the conditional statement
               print filteredDBT.timeStamps
        """

        def checkInputStatement(statement):
            stStatement = statement.lower().replace("and", "").replace("or", "")\
                    .replace("not", "").replace("in", "").replace("is", "")

            l = [s for s in stStatement if s.isalpha()]
            if list(set(l)) != ['x']:
                statementErrorMsg = 'Invalid input statement. Statement should be a valid Python statement' + \
                    ' and the variable should be named as x'
                raise ValueError(statementErrorMsg)

        checkInputStatement(statement)

        statement = statement.replace('x', 'd.value')
        filteredData = [d for d in self.__data if eval(statement)]

        # create a new filteredData
        filteredHeader = self.header.duplicate()
        filteredHeader.analysisPeriod = 'N/A'
        filteredDataList = DataList(filteredData, filteredHeader)

        return filteredDataList

    def filterByPattern(self, patternList):
        """Filter the list based on a list of Boolean

            Length of Boolean should be equal to length of values in DataList

            Parameters:
                patternList: A list of True, False values

            Return:
                A new DataList with filtered data
        """
        # check length of data vs length of analysis period
        if len(self.values) != len(patternList):
            print len(self.values), len(patternList)
            errMsg = "Length of values %d is not equal to number of patterns %d" \
                    %(len(self.values), len(patternList))
            raise ValueError(errMsg)

        filteredData = [d for count, d in enumerate(self.__data) if patternList[count]]

        # create a new filteredData
        filteredHeader = self.header.duplicate()
        filteredHeader.analysisPeriod = 'N/A'
        filteredDataList = DataList(filteredData, filteredHeader)

        return filteredDataList

    def averageMonthly(self, userDataList = None):
        """Return a dictionary of values for average values for available months"""

        # group data for each month
        monthlyValues = self.groupDataByMonth(userDataList= userDataList)

        averageValues = dict()

        # average values for each month
        for month, values in monthlyValues.items():
            averageValues[month] = self.average(values)

        return averageValues

    def averageMonthlyForEachHour(self, userDataList = None):
        """Calculate average value for each hour during each month

            This method returns a dictionary with nested dictionaries for each hour
        """
        # get monthy values
        monthlyHourlyValues = self.groupDataByMonth(userDataList= userDataList)

        # group data for each hour in each month and collect them in a dictionary
        averagedMonthlyValuesPerHour = {}
        for month, monthlyValues in monthlyHourlyValues.items():
            if month not in averagedMonthlyValuesPerHour: averagedMonthlyValuesPerHour[month] = {}

            # group data for each hour
            groupedHourlyData = self.groupDataByHour(userDataList = monthlyValues)
            for hour, data in groupedHourlyData.items():
                averagedMonthlyValuesPerHour[month][hour] = self.average(data)

        return averagedMonthlyValuesPerHour

    def __len__(self):
        return len(self.__data)

    def __getitem__(self, key):
        return self.__data[key]

    def __setitem__(self, key, value):
        self.__data[key] = value

    def __delitem__(self, key):
        del self.__data[key]

    def __iter__(self):
        return iter(self.__data)

    # TODO: Reverse analysis period in header
    def __reversed__(self):
        return FunctionalList(reversed(self.__data))

    def __repr__(self):
        return "Ladybug.DataList#%s"%self.header.dataType
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ladybug.core.DataList">DataList</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.average">
    <p>def <span class="ident">average</span>(</p><p>data)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.average', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.average" class="source">
    <pre><code>@staticmethod
def average(data):
    values = [value.value for value in data]
    return sum(values)/len(data)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ladybug.core.DataList.header" class="name">var <span class="ident">header</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.DataList.timeStamps" class="name">var <span class="ident">timeStamps</span></p>
            

            
  
    <div class="desc"><p>List of time stamps for current data</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, data=None, header=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.__init__" class="source">
    <pre><code>def __init__(self, data = None, header = None):
    self.__data = self.checkInputData(data)
    self.header = LBHeader() if not header else header
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.append">
    <p>def <span class="ident">append</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Append LBData to current list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.append', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.append" class="source">
    <pre><code>def append(self, data):
    """Append LBData to current list"""
    self.extend([data])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.averageMonthly">
    <p>def <span class="ident">averageMonthly</span>(</p><p>self, userDataList=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a dictionary of values for average values for available months</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.averageMonthly', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.averageMonthly" class="source">
    <pre><code>def averageMonthly(self, userDataList = None):
    """Return a dictionary of values for average values for available months"""
    # group data for each month
    monthlyValues = self.groupDataByMonth(userDataList= userDataList)
    averageValues = dict()
    # average values for each month
    for month, values in monthlyValues.items():
        averageValues[month] = self.average(values)
    return averageValues
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.averageMonthlyForEachHour">
    <p>def <span class="ident">averageMonthlyForEachHour</span>(</p><p>self, userDataList=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate average value for each hour during each month</p>
<p>This method returns a dictionary with nested dictionaries for each hour</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.averageMonthlyForEachHour', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.averageMonthlyForEachHour" class="source">
    <pre><code>def averageMonthlyForEachHour(self, userDataList = None):
    """Calculate average value for each hour during each month
        This method returns a dictionary with nested dictionaries for each hour
    """
    # get monthy values
    monthlyHourlyValues = self.groupDataByMonth(userDataList= userDataList)
    # group data for each hour in each month and collect them in a dictionary
    averagedMonthlyValuesPerHour = {}
    for month, monthlyValues in monthlyHourlyValues.items():
        if month not in averagedMonthlyValuesPerHour: averagedMonthlyValuesPerHour[month] = {}
        # group data for each hour
        groupedHourlyData = self.groupDataByHour(userDataList = monthlyValues)
        for hour, data in groupedHourlyData.items():
            averagedMonthlyValuesPerHour[month][hour] = self.average(data)
    return averagedMonthlyValuesPerHour
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.checkInputData">
    <p>def <span class="ident">checkInputData</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Check input data</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.checkInputData', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.checkInputData" class="source">
    <pre><code>def checkInputData(self, data):
    """Check input data"""
    if not data: return []
    return [LBData.fromLBData(d) for d in data]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.duplicate">
    <p>def <span class="ident">duplicate</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Duplicate current data list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.duplicate', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.duplicate" class="source">
    <pre><code>def duplicate(self):
    """Duplicate current data list"""
    return copy.deepcopy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.extend">
    <p>def <span class="ident">extend</span>(</p><p>self, dataList)</p>
    </div>
    

    
  
    <div class="desc"><p>Extend a list of LBData to the end of current list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.extend', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.extend" class="source">
    <pre><code>def extend(self, dataList):
    """Extend a list of LBData to the end of current list"""
    self.__data.extend(self.checkInputData(dataList))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.filterByAnalysisPeriod">
    <p>def <span class="ident">filterByAnalysisPeriod</span>(</p><p>self, analysisPeriod)</p>
    </div>
    

    
  
    <div class="desc"><p>Filter the list based on an analysis period
Parameters:
   analysis period: A Ladybug analysis period</p>
<p>Return:
    A new DataList with filtered data</p>
<p>Usage:
   analysisPeriod = AnalysisPeriod(2,1,1,3,31,24) #start of Feb to end of Mar
   epw = EPW("c:\ladybug\weatherdata.epw")
   DBT = epw.dryBulbTemperature
   filteredDBT = DBT.filterByAnalysisPeriod(analysisPeriod)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.filterByAnalysisPeriod', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.filterByAnalysisPeriod" class="source">
    <pre><code>def filterByAnalysisPeriod(self, analysisPeriod):
    """Filter the list based on an analysis period
        Parameters:
           analysis period: A Ladybug analysis period
        Return:
            A new DataList with filtered data
        Usage:
           analysisPeriod = AnalysisPeriod(2,1,1,3,31,24) #start of Feb to end of Mar
           epw = EPW("c:\ladybug\weatherdata.epw")
           DBT = epw.dryBulbTemperature
           filteredDBT = DBT.filterByAnalysisPeriod(analysisPeriod)
    """
    if not analysisPeriod or analysisPeriod.isAnnual:
        print "You need a valid analysis period to filter data."
        return self
    # There is no guarantee that data is continuous so I iterate through the
    # each data point one by one
    filteredData = [ d for d in self.__data if analysisPeriod.isTimeIncluded(d.datetime)]
    # create a new filteredData
    filteredHeader = self.header.duplicate()
    filteredHeader.analysisPeriod = analysisPeriod
    filteredDataList = DataList(filteredData, filteredHeader)
    return filteredDataList
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.filterByConditionalStatement">
    <p>def <span class="ident">filterByConditionalStatement</span>(</p><p>self, statement)</p>
    </div>
    

    
  
    <div class="desc"><p>Filter the list based on an analysis period
Parameters:
   statement: A conditional statement as a string (e.g. x&gt;25 and x%5==0).
    The variable should always be named as x</p>
<p>Return:
    A new DataList with filtered data</p>
<p>Usage:
   epw = EPW("c:\ladybug\weatherdata.epw")
   DBT = epw.dryBulbTemperature
   # filter data for when dry bulb temperature is more then 25
   filteredDBT = DBT.filterByConditionalStatement('x &gt; 25')
   # get the list of time stamps that meet the conditional statement
   print filteredDBT.timeStamps</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.filterByConditionalStatement', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.filterByConditionalStatement" class="source">
    <pre><code>def filterByConditionalStatement(self, statement):
    """Filter the list based on an analysis period
        Parameters:
           statement: A conditional statement as a string (e.g. x>25 and x%5==0).
            The variable should always be named as x
        Return:
            A new DataList with filtered data
        Usage:
           epw = EPW("c:\ladybug\weatherdata.epw")
           DBT = epw.dryBulbTemperature
           # filter data for when dry bulb temperature is more then 25
           filteredDBT = DBT.filterByConditionalStatement('x > 25')
           # get the list of time stamps that meet the conditional statement
           print filteredDBT.timeStamps
    """
    def checkInputStatement(statement):
        stStatement = statement.lower().replace("and", "").replace("or", "")\
                .replace("not", "").replace("in", "").replace("is", "")
        l = [s for s in stStatement if s.isalpha()]
        if list(set(l)) != ['x']:
            statementErrorMsg = 'Invalid input statement. Statement should be a valid Python statement' + \
                ' and the variable should be named as x'
            raise ValueError(statementErrorMsg)
    checkInputStatement(statement)
    statement = statement.replace('x', 'd.value')
    filteredData = [d for d in self.__data if eval(statement)]
    # create a new filteredData
    filteredHeader = self.header.duplicate()
    filteredHeader.analysisPeriod = 'N/A'
    filteredDataList = DataList(filteredData, filteredHeader)
    return filteredDataList
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.filterByHOYs">
    <p>def <span class="ident">filterByHOYs</span>(</p><p>self, HOYs)</p>
    </div>
    

    
  
    <div class="desc"><p>Filter the list based on an analysis period
Parameters:
   HOYs: A List of hours of the year [1-8760]</p>
<p>Return:
    A new DataList with filtered data</p>
<p>Usage:
   HOYs = range(1,48) # The first two days of the year
   epw = EPW("c:\ladybug\weatherdata.epw")
   DBT = epw.dryBulbTemperature
   filteredDBT = DBT.filterByHOYs(HOYs)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.filterByHOYs', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.filterByHOYs" class="source">
    <pre><code>def filterByHOYs(self, HOYs):
    """Filter the list based on an analysis period
        Parameters:
           HOYs: A List of hours of the year [1-8760]
        Return:
            A new DataList with filtered data
        Usage:
           HOYs = range(1,48) # The first two days of the year
           epw = EPW("c:\ladybug\weatherdata.epw")
           DBT = epw.dryBulbTemperature
           filteredDBT = DBT.filterByHOYs(HOYs)
    """
    # There is no guarantee that data is continuous so I iterate through the
    # each data point one by one
    filteredData = [ d for d in self.__data if d.datetime.HOY in HOYs]
    # create a new filteredData
    filteredHeader = self.header.duplicate()
    filteredHeader.analysisPeriod = "unknown"
    filteredDataList = DataList(filteredData, filteredHeader)
    return filteredDataList
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.filterByPattern">
    <p>def <span class="ident">filterByPattern</span>(</p><p>self, patternList)</p>
    </div>
    

    
  
    <div class="desc"><p>Filter the list based on a list of Boolean</p>
<p>Length of Boolean should be equal to length of values in DataList</p>
<p>Parameters:
    patternList: A list of True, False values</p>
<p>Return:
    A new DataList with filtered data</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.filterByPattern', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.filterByPattern" class="source">
    <pre><code>def filterByPattern(self, patternList):
    """Filter the list based on a list of Boolean
        Length of Boolean should be equal to length of values in DataList
        Parameters:
            patternList: A list of True, False values
        Return:
            A new DataList with filtered data
    """
    # check length of data vs length of analysis period
    if len(self.values) != len(patternList):
        print len(self.values), len(patternList)
        errMsg = "Length of values %d is not equal to number of patterns %d" \
                %(len(self.values), len(patternList))
        raise ValueError(errMsg)
    filteredData = [d for count, d in enumerate(self.__data) if patternList[count]]
    # create a new filteredData
    filteredHeader = self.header.duplicate()
    filteredHeader.analysisPeriod = 'N/A'
    filteredDataList = DataList(filteredData, filteredHeader)
    return filteredDataList
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.groupDataByDay">
    <p>def <span class="ident">groupDataByDay</span>(</p><p>self, dayRange=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365], userDataList=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a dictionary of values where values are grouped by each day of year</p>
<p>key values are between 1-365</p>
<p>Parameters:
    dayRange: A list of numbers for days. Default is 1-365
    userDataList: An optional data list of LBData to be processed
Usage:
    epwfile = EPW("epw file address")
    dailyValues = epwfile.dryBulbTemperature.groupDataByDay(range(1, 30))
    print dailyValues[2] # returns values for the second day of year</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.groupDataByDay', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.groupDataByDay" class="source">
    <pre><code>def groupDataByDay(self, dayRange = range(1, 366), userDataList = None):
    """Return a dictionary of values where values are grouped by each day of year
        key values are between 1-365
       Parameters:
           dayRange: A list of numbers for days. Default is 1-365
           userDataList: An optional data list of LBData to be processed
       Usage:
           epwfile = EPW("epw file address")
           dailyValues = epwfile.dryBulbTemperature.groupDataByDay(range(1, 30))
           print dailyValues[2] # returns values for the second day of year
    """
    hourlyDataByDay = {}
    if userDataList:
        data = [LBData.fromLBData(d) for d in userDataList]
    else:
        data = self.__data
    for d in data:
        DOY = DateTimeLib.getDayOfYear(d.datetime.month, d.datetime.day)
        if not DOY in dayRange: continue
        if not hourlyDataByDay.has_key(DOY): hourlyDataByDay[DOY] = [] #create an empty list for month
        hourlyDataByDay[DOY].append(d)
    print "Found data for " + str(len(hourlyDataByDay.keys())) + " days."
    return hourlyDataByDay
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.groupDataByHour">
    <p>def <span class="ident">groupDataByHour</span>(</p><p>self, hourRange=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], userDataList=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a dictionary of values where values are grouped by each hour of day</p>
<p>key values are between 1-24</p>
<p>Parameters:
    hourRange: A list of numbers for hours. Default is 1-24
    userDataList: An optional data list of LBData to be processed</p>
<p>Usage:
    epwfile = EPW("epw file address")
    monthlyValues = epwfile.dryBulbTemperature.groupDataByMonth([1])
    groupedHourlyData = epwfile.dryBulbTemperature.groupDataByHour(userDataList = monthlyValues[2])
    for hour, data in groupedHourlyData.items():
        print "average temperature values for hour " + str(hour) + " during JAN is " + str(core.DataList.average(data)) + " " + DBT.header.unit</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.groupDataByHour', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.groupDataByHour" class="source">
    <pre><code>def groupDataByHour(self, hourRange = range(1, 25), userDataList = None):
    """Return a dictionary of values where values are grouped by each hour of day
        key values are between 1-24
       Parameters:
           hourRange: A list of numbers for hours. Default is 1-24
           userDataList: An optional data list of LBData to be processed
       Usage:
           epwfile = EPW("epw file address")
           monthlyValues = epwfile.dryBulbTemperature.groupDataByMonth([1])
           groupedHourlyData = epwfile.dryBulbTemperature.groupDataByHour(userDataList = monthlyValues[2])
           for hour, data in groupedHourlyData.items():
               print "average temperature values for hour " + str(hour) + " during JAN is " + str(core.DataList.average(data)) + " " + DBT.header.unit
    """
    hourlyDataByHour = {}
    if userDataList:
        data = [LBData.fromLBData(d) for d in userDataList]
    else:
        data = self.__data
    for d in data:
        if not d.datetime.hour in hourRange: continue
        if not hourlyDataByHour.has_key(d.datetime.hour): hourlyDataByHour[d.datetime.hour] = [] #create an empty list for month
        hourlyDataByHour[d.datetime.hour].append(d)
    print "Found data for hours " + str(hourlyDataByHour.keys())
    return hourlyDataByHour
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.groupDataByMonth">
    <p>def <span class="ident">groupDataByMonth</span>(</p><p>self, monthRange=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], userDataList=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a dictionary of values where values are grouped for each month</p>
<p>key values are between 1-12</p>
<p>Parameters:
    monthRange: A list of numbers for months. Default is 1-12
    userDataList: An optional data list of LBData to be processed</p>
<p>Usage:
    epwfile = EPW("epw file address")
    monthlyValues = epwfile.dryBulbTemperature.groupValuesByMonth()
    print monthlyValues[2] # returns values for the month of March</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.groupDataByMonth', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.groupDataByMonth" class="source">
    <pre><code>def groupDataByMonth(self, monthRange = range(1,13), userDataList = None):
    """Return a dictionary of values where values are grouped for each month
        key values are between 1-12
       Parameters:
           monthRange: A list of numbers for months. Default is 1-12
           userDataList: An optional data list of LBData to be processed
       Usage:
           epwfile = EPW("epw file address")
           monthlyValues = epwfile.dryBulbTemperature.groupValuesByMonth()
           print monthlyValues[2] # returns values for the month of March
    """
    hourlyDataByMonth = {}
    if userDataList:
        data = [LBData.fromLBData(d) for d in userDataList]
    else:
        data = self.__data
    for d in data:
        if not d.datetime.month in monthRange: continue
        if not hourlyDataByMonth.has_key(d.datetime.month): hourlyDataByMonth[d.datetime.month] = [] #create an empty list for month
        hourlyDataByMonth[d.datetime.month].append(d)
    print "Found data for months " + str(hourlyDataByMonth.keys())
    return hourlyDataByMonth
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.updateDataForAnAnalysisPeriod">
    <p>def <span class="ident">updateDataForAnAnalysisPeriod</span>(</p><p>self, values, analysisPeriod=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Replace current values in data list with new set of values
for a specific analysis period.</p>
<p>Length of values should be equal to number of hours in analysis period</p>
<p>Parameters:
    values: A list of values to be replaced in the file
    analysisPeriod: An analysis period for input the input values.
        Default is set to the whole year.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.updateDataForAnAnalysisPeriod', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.updateDataForAnAnalysisPeriod" class="source">
    <pre><code>def updateDataForAnAnalysisPeriod(self, values, analysisPeriod = None):
    """Replace current values in data list with new set of values
        for a specific analysis period.
        Length of values should be equal to number of hours in analysis period
        Parameters:
            values: A list of values to be replaced in the file
            analysisPeriod: An analysis period for input the input values.
                Default is set to the whole year.
    """
    if not analysisPeriod:
        analysisPeriod = AnalysisPeriod()
    # check length of data vs length of analysis period
    if len(values) != analysisPeriod.totalNumOfHours:
        raise ValueError("Length of values %d is not equal to " + \
            "number of hours in analysis period %d"%(len(values), \
                                                    analysisPeriod.totalNumOfHours))
    # get all time stamps
    timeStamps = analysisPeriod.dates
    # map timeStamps and values
    newValues = {}
    for count, value in enumerate(values):
        HOY = timeStamps[count].HOY
        newValues[HOY] = value
    # update values
    updatedCount = 0
    for counter, data in enumerate(self.__data):
        try:
            value = newValues[data.datetime.HOY]
            data.updateValue(value)
            updatedCount+=1
        except KeyError:
            pass
    # return self for chaining methods
    print "%s data are updated for %d hours."%(self.header.dataType, updatedCount)
    # return self for chaining methods
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.updateDataForAnHour">
    <p>def <span class="ident">updateDataForAnHour</span>(</p><p>self, value, hourOfYear)</p>
    </div>
    

    
  
    <div class="desc"><p>Replace current value in data list with a new value
for a specific hour of the year</p>
<p>Parameters:
    value: A single value
    hoursOfYear: The hour of the year</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.updateDataForAnHour', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.updateDataForAnHour" class="source">
    <pre><code>def updateDataForAnHour(self, value, hourOfYear):
    """Replace current value in data list with a new value
        for a specific hour of the year
        Parameters:
            value: A single value
            hoursOfYear: The hour of the year
    """
    return self.updateDataForHoursOfYear([value], [hourOfYear])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.updateDataForHoursOfYear">
    <p>def <span class="ident">updateDataForHoursOfYear</span>(</p><p>self, values, hoursOfYear)</p>
    </div>
    

    
  
    <div class="desc"><p>Replace current values in data list with new set of values
for a list of hours of year</p>
<p>Length of values should be equal to number of hours in hours of year</p>
<p>Parameters:
    values: A list of values to be replaced in the file
    hoursOfYear: A list of HOY between 1 and 8760</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.updateDataForHoursOfYear', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.updateDataForHoursOfYear" class="source">
    <pre><code>def updateDataForHoursOfYear(self, values, hoursOfYear):
    """Replace current values in data list with new set of values
        for a list of hours of year
        Length of values should be equal to number of hours in hours of year
        Parameters:
            values: A list of values to be replaced in the file
            hoursOfYear: A list of HOY between 1 and 8760
    """
    # check length of data vs length of analysis period
    if len(values) != len(hoursOfYear):
        raise ValueError("Length of values %d is not equal to " + \
            "number of hours in analysis period %d"%(len(values), \
                                                    len(hoursOfYear)))
    # map hours and values
    newValues = {}
    for count, value in enumerate(values):
        HOY = hoursOfYear[count]
        newValues[HOY] = value
    # update values
    updatedCount = 0
    for counter, data in enumerate(self.__data):
        try:
            value = newValues[data.datetime.HOY]
            data.updateValue(value)
            updatedCount+=1
        except KeyError:
            pass
    print "%s data %s updated for %d hour%s."%(self.header.dataType, \
            'are' if len(values)>1 else 'is', updatedCount,\
            's' if len(values)>1 else '')
    # return self for chaining methods
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DataList.values">
    <p>def <span class="ident">values</span>(</p><p>self, header=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the list of values</p>
<p>Args:
    header: A boolean that indicates if values should include the headers</p>
<p>Return:
    A list of values</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DataList.values', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DataList.values" class="source">
    <pre><code>def values(self, header = False):
    """Return the list of values
        Args:
            header: A boolean that indicates if values should include the headers
        Return:
            A list of values
    """
    if not header:
        return self.__data
    else:
        return self.header.toList() + self.__data
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ladybug.core.DateTimeLib" class="name">class <span class="ident">DateTimeLib</span></p>
      
  
    <div class="desc"><p>Ladybug DateTime Libray
This class includes useful data and methods for date and time</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DateTimeLib', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DateTimeLib" class="source">
    <pre><code>class DateTimeLib:
    """Ladybug DateTime Libray
    This class includes useful data and methods for date and time
    """
    monthList = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
    numOfDaysEachMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    numOfDaysUntilMonth = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]
    numOfHoursUntilMonth = [24 * numOfDay for numOfDay in numOfDaysUntilMonth]

    @classmethod
    def checkDateTime(cls, month, day, hour, minute = None):
        """Checks if time combination is a valid time."""
        # check month
        if not 1 <= month <= 12:
            raise ValueError("month should be between 1-12")

        if day < 1 or day > cls.numOfDaysEachMonth[month-1]:
            raise ValueError("Number of days for %s should be \
                    between 1-%d"%(cls.monthList[month-1], cls.numOfDaysEachMonth[month-1]))

        if not 0 <= hour <= 24:
            raise ValueError("hour should be between 0.0-24.0")

        if not minute or minute == 0:
            if hour == 0 and day == 1 and month == 1:
                # last hour of the year
                month = 12
                day = 31
                hour = 24

            elif hour == 0 and day == 1:
                # The last hour of the last day of the month before
                month -= 1
                day = cls.numOfDaysEachMonth[month-1]
                hour = 24

            elif hour==0:
                # the last hour of the day before
                hour = 24
                day -= 1

        hour, minute = cls.__getHourAndMinute(hour, minute)

        return month, day, hour, minute

    @classmethod
    def getHourOfYear(cls, month, day, hour, minute = None):
        """Return hour of the year between 1 and 8760."""
        # make sure input values are correct
        month, day, hour, minute = cls.checkDateTime(month, day, hour, minute)

        # fix the end day
        JD = cls.numOfDaysUntilMonth[month-1] + int(day)
        return (JD - 1) * 24 + hour

    @classmethod
    def getDayOfYear(cls, month, day):
        """Retuen day of the year between 1 and 365"""
        # make sure input values are correct
        month, day, hour, minute = cls.checkDateTime(month, day, hour = 1)

        # fix the end day
        return cls.numOfDaysUntilMonth[month-1] + int(day)

    @classmethod
    def getMonthDayHourAndMinute(cls, hourOfYear):
        """Return month, day and hour for an hour of the year"""
        if hourOfYear == 8760: return 12, 31, 24, 0

        # find month
        for monthCount in range(12):
            if hourOfYear <= cls.numOfHoursUntilMonth[monthCount + 1]:
                month = monthCount + 1
                break

        # find day and hour
        if hourOfYear%24 == 0:
            # last hour of the day
            day = int((hourOfYear - cls.numOfHoursUntilMonth[month - 1])/24)
            hour = 24
            minute = 0
        else:
            day = int((hourOfYear - cls.numOfHoursUntilMonth[month - 1])/24) + 1
            hour = int(hourOfYear%24)
            minute = cls.__getHourAndMinute(hourOfYear)[1]

        return month, day, hour, minute

    @staticmethod
    def __getHourAndMinute(hour, minute = None):

        """Calculate and return hour and minute

            This method is mainly usefule for calculating minutes from float hours
            if minute is missing. otherwise it will only check the inputs append
            returns the checked values

            Args:
                hour: A float value between 0.0-24.0
                minutes: An integer between 0-59. Default in None

            Returns:
                hour: An interger between 0-24
                minute: An integer between 0-59
        """
        if not minute:
            minute = (hour - int(hour)) * 60

        # cast values to integer
        hour = int(hour + int(minute/60))
        minute = minute%60

        return hour, minute
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ladybug.core.DateTimeLib">DateTimeLib</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ladybug.core.DateTimeLib.monthList" class="name">var <span class="ident">monthList</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.DateTimeLib.numOfDay" class="name">var <span class="ident">numOfDay</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.DateTimeLib.numOfDaysEachMonth" class="name">var <span class="ident">numOfDaysEachMonth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.DateTimeLib.numOfDaysUntilMonth" class="name">var <span class="ident">numOfDaysUntilMonth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.DateTimeLib.numOfHoursUntilMonth" class="name">var <span class="ident">numOfHoursUntilMonth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.DateTimeLib.checkDateTime">
    <p>def <span class="ident">checkDateTime</span>(</p><p>cls, month, day, hour, minute=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if time combination is a valid time.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DateTimeLib.checkDateTime', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DateTimeLib.checkDateTime" class="source">
    <pre><code>@classmethod
def checkDateTime(cls, month, day, hour, minute = None):
    """Checks if time combination is a valid time."""
    # check month
    if not 1 <= month <= 12:
        raise ValueError("month should be between 1-12")
    if day < 1 or day > cls.numOfDaysEachMonth[month-1]:
        raise ValueError("Number of days for %s should be \
                between 1-%d"%(cls.monthList[month-1], cls.numOfDaysEachMonth[month-1]))
    if not 0 <= hour <= 24:
        raise ValueError("hour should be between 0.0-24.0")
    if not minute or minute == 0:
        if hour == 0 and day == 1 and month == 1:
            # last hour of the year
            month = 12
            day = 31
            hour = 24
        elif hour == 0 and day == 1:
            # The last hour of the last day of the month before
            month -= 1
            day = cls.numOfDaysEachMonth[month-1]
            hour = 24
        elif hour==0:
            # the last hour of the day before
            hour = 24
            day -= 1
    hour, minute = cls.__getHourAndMinute(hour, minute)
    return month, day, hour, minute
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DateTimeLib.getDayOfYear">
    <p>def <span class="ident">getDayOfYear</span>(</p><p>cls, month, day)</p>
    </div>
    

    
  
    <div class="desc"><p>Retuen day of the year between 1 and 365</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DateTimeLib.getDayOfYear', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DateTimeLib.getDayOfYear" class="source">
    <pre><code>@classmethod
def getDayOfYear(cls, month, day):
    """Retuen day of the year between 1 and 365"""
    # make sure input values are correct
    month, day, hour, minute = cls.checkDateTime(month, day, hour = 1)
    # fix the end day
    return cls.numOfDaysUntilMonth[month-1] + int(day)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DateTimeLib.getHourOfYear">
    <p>def <span class="ident">getHourOfYear</span>(</p><p>cls, month, day, hour, minute=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return hour of the year between 1 and 8760.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DateTimeLib.getHourOfYear', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DateTimeLib.getHourOfYear" class="source">
    <pre><code>@classmethod
def getHourOfYear(cls, month, day, hour, minute = None):
    """Return hour of the year between 1 and 8760."""
    # make sure input values are correct
    month, day, hour, minute = cls.checkDateTime(month, day, hour, minute)
    # fix the end day
    JD = cls.numOfDaysUntilMonth[month-1] + int(day)
    return (JD - 1) * 24 + hour
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.DateTimeLib.getMonthDayHourAndMinute">
    <p>def <span class="ident">getMonthDayHourAndMinute</span>(</p><p>cls, hourOfYear)</p>
    </div>
    

    
  
    <div class="desc"><p>Return month, day and hour for an hour of the year</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.DateTimeLib.getMonthDayHourAndMinute', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.DateTimeLib.getMonthDayHourAndMinute" class="source">
    <pre><code>@classmethod
def getMonthDayHourAndMinute(cls, hourOfYear):
    """Return month, day and hour for an hour of the year"""
    if hourOfYear == 8760: return 12, 31, 24, 0
    # find month
    for monthCount in range(12):
        if hourOfYear <= cls.numOfHoursUntilMonth[monthCount + 1]:
            month = monthCount + 1
            break
    # find day and hour
    if hourOfYear%24 == 0:
        # last hour of the day
        day = int((hourOfYear - cls.numOfHoursUntilMonth[month - 1])/24)
        hour = 24
        minute = 0
    else:
        day = int((hourOfYear - cls.numOfHoursUntilMonth[month - 1])/24) + 1
        hour = int(hourOfYear%24)
        minute = cls.__getHourAndMinute(hourOfYear)[1]
    return month, day, hour, minute
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ladybug.core.LBData" class="name">class <span class="ident">LBData</span></p>
      
  
    <div class="desc"><p>Ladybug data point</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBData', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBData" class="source">
    <pre><code>class LBData:
    """Ladybug data point"""

    # TODO: Change value to be an object from it's data type
    #       Check datatype.py for available datatypes

    def __init__(self, value, dateTime):
        self.datetime = dateTime
        self.value = value

    @classmethod
    def fromLBData(cls, data):
        assert isinstance(data, LBData), "Input is not a LBData."
        return data

    def updateValue(self, newValue):
        self.value = newValue

    def __int__(self):
        return int(self.value)

    def __float__(self):
        return float(self.value)

    def __str__(self):
        return str(self.value)

    def __eq__(self, other):
        return  self.value == float(other)

    def __ne__(self, other):
        return  self.value != float(other)

    def __lt__(self, other):
        return self.value < other

    def __gt__(self, other):
        return self.value > other

    def __le__(self, other):
        return self.value <= other

    def __ge__(self, other):
        return self.value >= other

    def __add__(self, other):
        return self.value + other

    def __sub__(self, other):
        return self.value - other

    def __mul__(self, other):
        return self.value * other

    def __floordiv__(self, other):
        return self.value // other

    def __div__(self, other):
        return self.value / other

    def __mod__(self, other):
        return self.value%other

    def __pow__(self, other):
        return self.value**other

    def __radd__(self, other):
        return self.__add__(other)

    def __rsub__(self, other):
        return other - self.value

    def __rmul__(self, other):
        return self.__mul__(other)

    def __rfloordiv__(self, other):
        return other//self.value

    def __rdiv__(self, other):
        return other/self.value

    def __rmod__(self, other):
        return other%self.value

    def __rpow__(self, other):
        return other**self.value

    def __repr__(self):
        return self.__str__()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ladybug.core.LBData">LBData</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ladybug.core.LBData.datetime" class="name">var <span class="ident">datetime</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBData.value" class="name">var <span class="ident">value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBData.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, value, dateTime)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBData.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBData.__init__" class="source">
    <pre><code>def __init__(self, value, dateTime):
    self.datetime = dateTime
    self.value = value
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBData.fromLBData">
    <p>def <span class="ident">fromLBData</span>(</p><p>cls, data)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBData.fromLBData', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBData.fromLBData" class="source">
    <pre><code>@classmethod
def fromLBData(cls, data):
    assert isinstance(data, LBData), "Input is not a LBData."
    return data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBData.updateValue">
    <p>def <span class="ident">updateValue</span>(</p><p>self, newValue)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBData.updateValue', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBData.updateValue" class="source">
    <pre><code>def updateValue(self, newValue):
    self.value = newValue
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ladybug.core.LBDateTime" class="name">class <span class="ident">LBDateTime</span></p>
      
  
    <div class="desc"><p>Ladybug Date time</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBDateTime', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBDateTime" class="source">
    <pre><code>class LBDateTime:
    """Ladybug Date time"""
    def __init__(self, month = 1, day = 1, hour = 1, minute = None):
        self.month, self.day, self.hour, \
            self.minute = DateTimeLib.checkDateTime(month, day, hour, minute)

        self.floatHour = self.hour + self.minute/60.0
        self.DOY = DateTimeLib.getDayOfYear(self.month, self.day)
        self.HOY = DateTimeLib.getHourOfYear(self.month, self.day, self.hour, self.minute)
        self.MOY = self.HOY * 60  + self.minute # minute of the year
        self.floatHOY = self.HOY + self.minute/60.0

    @classmethod
    def fromHOY(cls, HOY):
        """Create Ladybug Datetime from an hour of the year

            Args:
                HOY: A float value between 0.0 to 8760.0
        """
        month, day, hour, minute = DateTimeLib.getMonthDayHourAndMinute(HOY)
        return cls(month, day, hour, minute)

    @classmethod
    def fromMOY(cls, MOY):
        """create Ladybug DateTime from Minute of the year"""
        HOY = MOY/60.0
        return cls.fromHOY(HOY)

    @classmethod
    def fromDateTimeString(cls, datetimeString):
        day, month, hour, minute = datetimeString \
                .replace(" at ", " ") \
                .replace(":", " ") \
                .split(" ")

        month = DateTimeLib.monthList.index(month.upper()) + 1

        return cls(month, int(day), int(hour), int(minute))

    @property
    def humanReadableHour(self):
        """Return hours and minutes in a human readable way"""
        minute = str(self.minute)
        if len(minute) == 1: minute = "0" + minute
        return "%d:%s"%(self.hour, minute)

    def __repr__(self):
        return "%d %s at %s"%( self.day, DateTimeLib.monthList[self.month-1], self.humanReadableHour)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ladybug.core.LBDateTime">LBDateTime</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ladybug.core.LBDateTime.DOY" class="name">var <span class="ident">DOY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBDateTime.HOY" class="name">var <span class="ident">HOY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBDateTime.MOY" class="name">var <span class="ident">MOY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBDateTime.floatHOY" class="name">var <span class="ident">floatHOY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBDateTime.floatHour" class="name">var <span class="ident">floatHour</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBDateTime.humanReadableHour" class="name">var <span class="ident">humanReadableHour</span></p>
            

            
  
    <div class="desc"><p>Return hours and minutes in a human readable way</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBDateTime.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, month=1, day=1, hour=1, minute=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBDateTime.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBDateTime.__init__" class="source">
    <pre><code>def __init__(self, month = 1, day = 1, hour = 1, minute = None):
    self.month, self.day, self.hour, \
        self.minute = DateTimeLib.checkDateTime(month, day, hour, minute)
    self.floatHour = self.hour + self.minute/60.0
    self.DOY = DateTimeLib.getDayOfYear(self.month, self.day)
    self.HOY = DateTimeLib.getHourOfYear(self.month, self.day, self.hour, self.minute)
    self.MOY = self.HOY * 60  + self.minute # minute of the year
    self.floatHOY = self.HOY + self.minute/60.0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBDateTime.fromDateTimeString">
    <p>def <span class="ident">fromDateTimeString</span>(</p><p>cls, datetimeString)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBDateTime.fromDateTimeString', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBDateTime.fromDateTimeString" class="source">
    <pre><code>@classmethod
def fromDateTimeString(cls, datetimeString):
    day, month, hour, minute = datetimeString \
            .replace(" at ", " ") \
            .replace(":", " ") \
            .split(" ")
    month = DateTimeLib.monthList.index(month.upper()) + 1
    return cls(month, int(day), int(hour), int(minute))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBDateTime.fromHOY">
    <p>def <span class="ident">fromHOY</span>(</p><p>cls, HOY)</p>
    </div>
    

    
  
    <div class="desc"><p>Create Ladybug Datetime from an hour of the year</p>
<p>Args:
    HOY: A float value between 0.0 to 8760.0</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBDateTime.fromHOY', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBDateTime.fromHOY" class="source">
    <pre><code>@classmethod
def fromHOY(cls, HOY):
    """Create Ladybug Datetime from an hour of the year
        Args:
            HOY: A float value between 0.0 to 8760.0
    """
    month, day, hour, minute = DateTimeLib.getMonthDayHourAndMinute(HOY)
    return cls(month, day, hour, minute)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBDateTime.fromMOY">
    <p>def <span class="ident">fromMOY</span>(</p><p>cls, MOY)</p>
    </div>
    

    
  
    <div class="desc"><p>create Ladybug DateTime from Minute of the year</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBDateTime.fromMOY', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBDateTime.fromMOY" class="source">
    <pre><code>@classmethod
def fromMOY(cls, MOY):
    """create Ladybug DateTime from Minute of the year"""
    HOY = MOY/60.0
    return cls.fromHOY(HOY)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ladybug.core.LBHeader" class="name">class <span class="ident">LBHeader</span></p>
      
  
    <div class="desc"><p>Standard Ladybug header for lists.</p>
<p>The header carries data for city,
data type, unit, and analysis period</p>
<p>Attributes:
    city: A string for the city name
    dataType: A valid Ladybug data type. Try DataType.dataTypes to see list of data types
    unit: dataType unit. If empty string it will be set based on dataType
    timestep: Data timestep "Hourly", "Daily", "Monthly", "Annual", "N/A"
    analysisPeriod: A Ladybug analysis period. (defualt: 1 Jan 1 to 31 Dec 24)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBHeader', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBHeader" class="source">
    <pre><code>class LBHeader:
    """Standard Ladybug header for lists.

        The header carries data for city,
        data type, unit, and analysis period

        Attributes:
            city: A string for the city name
            dataType: A valid Ladybug data type. Try DataType.dataTypes to see list of data types
            unit: dataType unit. If empty string it will be set based on dataType
            timestep: Data timestep "Hourly", "Daily", "Monthly", "Annual", "N/A"
            analysisPeriod: A Ladybug analysis period. (defualt: 1 Jan 1 to 31 Dec 24)
    """

    def __init__(self, city = 'unknown', dataType = 'unknown', unit = 'unknown', frequency = 'unknown', analysisPeriod = None):
        """Initiate Ladybug header for lists."""
        self.city = city
        self.dataType = dataType
        self.unit = unit
        self.frequency = frequency
        self.analysisPeriod = 'unknown' if not analysisPeriod \
                else AnalysisPeriod.fromAnalysisPeriod(analysisPeriod)

    def duplicate(self):
        return copy.deepcopy(self)

    @property
    def __key(self):
        return 'location|dataType|units|frequency|dataPeriod'

    def toList(self):
        """Return Ladybug header as a list"""
        return [
                 self.__key,
                 self.city,
                 self.dataType,
                 self.unit,
                 self.frequency,
                 self.analysisPeriod
               ]

    def __repr__(self):
        return "%s for %s during %s"%(self.dataType, self.city, self.analysisPeriod)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ladybug.core.LBHeader">LBHeader</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ladybug.core.LBHeader.analysisPeriod" class="name">var <span class="ident">analysisPeriod</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBHeader.city" class="name">var <span class="ident">city</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBHeader.dataType" class="name">var <span class="ident">dataType</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBHeader.frequency" class="name">var <span class="ident">frequency</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBHeader.unit" class="name">var <span class="ident">unit</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBHeader.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, city=&#39;unknown&#39;, dataType=&#39;unknown&#39;, unit=&#39;unknown&#39;, frequency=&#39;unknown&#39;, analysisPeriod=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initiate Ladybug header for lists.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBHeader.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBHeader.__init__" class="source">
    <pre><code>def __init__(self, city = 'unknown', dataType = 'unknown', unit = 'unknown', frequency = 'unknown', analysisPeriod = None):
    """Initiate Ladybug header for lists."""
    self.city = city
    self.dataType = dataType
    self.unit = unit
    self.frequency = frequency
    self.analysisPeriod = 'unknown' if not analysisPeriod \
            else AnalysisPeriod.fromAnalysisPeriod(analysisPeriod)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBHeader.duplicate">
    <p>def <span class="ident">duplicate</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBHeader.duplicate', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBHeader.duplicate" class="source">
    <pre><code>def duplicate(self):
    return copy.deepcopy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBHeader.toList">
    <p>def <span class="ident">toList</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return Ladybug header as a list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBHeader.toList', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBHeader.toList" class="source">
    <pre><code>def toList(self):
    """Return Ladybug header as a list"""
    return [
             self.__key,
             self.city,
             self.dataType,
             self.unit,
             self.frequency,
             self.analysisPeriod
           ]
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ladybug.core.LBPatchData" class="name">class <span class="ident">LBPatchData</span></p>
      
  
    <div class="desc"><p>Ladybug sky patch data type</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBPatchData', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBPatchData" class="source">
    <pre><code>class LBPatchData(LBData):
    """Ladybug sky patch data type"""
    def __init__(self, value, vector):
        # sky data doesn't have time
        datetime = LBDateTime()
        LBData.__init__(self, value, datetime)
        self.vector = euclid.Vector3(*vector)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ladybug.core.LBPatchData">LBPatchData</a></li>
          <li><a href="#ladybug.core.LBData">LBData</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ladybug.core.LBPatchData.datetime" class="name">var <span class="ident">datetime</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ladybug.core.LBData">LBData</a></code>.<code><a href="#ladybug.core.LBData.datetime">datetime</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBPatchData.value" class="name">var <span class="ident">value</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ladybug.core.LBData">LBData</a></code>.<code><a href="#ladybug.core.LBData.value">value</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.LBPatchData.vector" class="name">var <span class="ident">vector</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBPatchData.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, value, vector)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ladybug.core.LBData">LBData</a></code>.<code><a href="#ladybug.core.LBData.__init__">__init__</a></code>
    </p>

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBPatchData.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBPatchData.__init__" class="source">
    <pre><code>def __init__(self, value, vector):
    # sky data doesn't have time
    datetime = LBDateTime()
    LBData.__init__(self, value, datetime)
    self.vector = euclid.Vector3(*vector)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBPatchData.fromLBData">
    <p>def <span class="ident">fromLBData</span>(</p><p>cls, data)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ladybug.core.LBData">LBData</a></code>.<code><a href="#ladybug.core.LBData.fromLBData">fromLBData</a></code>
    </p>

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBPatchData.fromLBData', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBPatchData.fromLBData" class="source">
    <pre><code>@classmethod
def fromLBData(cls, data):
    assert isinstance(data, LBData), "Input is not a LBData."
    return data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.LBPatchData.updateValue">
    <p>def <span class="ident">updateValue</span>(</p><p>self, newValue)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ladybug.core.LBData">LBData</a></code>.<code><a href="#ladybug.core.LBData.updateValue">updateValue</a></code>
    </p>

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.LBPatchData.updateValue', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.LBPatchData.updateValue" class="source">
    <pre><code>def updateValue(self, newValue):
    self.value = newValue
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ladybug.core.Location" class="name">class <span class="ident">Location</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.Location', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.Location" class="source">
    <pre><code>class Location:

    def __init__(self, city = '', country = '', latitude = '0.00', \
                longitude = '0.00', timeZone = '0.00', elevation ='0.00', \
                source = '', stationId = ''):

        self.city = str(city)
        self.country = str(country)
        self.latitude = float(latitude)
        self.longitude = float(longitude)
        self.timeZone = float(timeZone)
        self.elevation = float(elevation)
        self.source = str(source)
        self.stationId = str(stationId)

    def createFromEPString(self, EPString):
        """Create a Ladybug location from an EnergyPlus location string
            Parameters:
                EPString: Standard EP location string

            Usage:
                l = Location() #initiate location
                l.createFromEPString(EPString)
                print "LAT:%s, LON:%s"%(l.latitude, l.longitude)
        """

        try:
            self.city, self.latitude, \
            self.longitude, self.timeZone, \
            self.elevation = re.findall(r'\r*\n*([a-zA-Z0-9.:_-]*)[,|;]', \
                                    EPString, re.DOTALL)[1:]

            self.latitude = float(self.latitude)
            self.longitude = float(self.longitude)
            self.timeZone = float(self.timeZone)
            self.elevation = float(self.elevation)
        except Exception, e:
            raise Exception ("Failed to import EP string! %s"%str(e))

    def duplicate(self):
        return copy.deepcopy(self)

    @property
    def EPStyleLocationString(self):
        """Return EnergyPlus's location string"""
        return "Site:Location,\n" + \
            self.city + ',\n' + \
            str(self.latitude) +',      !Latitude\n' + \
            str(self.longitude) +',     !Longitude\n' + \
            str(self.timeZone) +',     !Time Zone\n' + \
            str(self.elevation) + ';       !Elevation'

    def __repr__(self):
        return "%s"%(self.EPStyleLocationString)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ladybug.core.Location">Location</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ladybug.core.Location.EPStyleLocationString" class="name">var <span class="ident">EPStyleLocationString</span></p>
            

            
  
    <div class="desc"><p>Return EnergyPlus's location string</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.Location.city" class="name">var <span class="ident">city</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.Location.country" class="name">var <span class="ident">country</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.Location.elevation" class="name">var <span class="ident">elevation</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.Location.latitude" class="name">var <span class="ident">latitude</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.Location.longitude" class="name">var <span class="ident">longitude</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.Location.source" class="name">var <span class="ident">source</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.Location.stationId" class="name">var <span class="ident">stationId</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ladybug.core.Location.timeZone" class="name">var <span class="ident">timeZone</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ladybug.core.Location.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, city=&#39;&#39;, country=&#39;&#39;, latitude=&#39;0.00&#39;, longitude=&#39;0.00&#39;, timeZone=&#39;0.00&#39;, elevation=&#39;0.00&#39;, source=&#39;&#39;, stationId=&#39;&#39;)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.Location.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.Location.__init__" class="source">
    <pre><code>def __init__(self, city = '', country = '', latitude = '0.00', \
            longitude = '0.00', timeZone = '0.00', elevation ='0.00', \
            source = '', stationId = ''):
    self.city = str(city)
    self.country = str(country)
    self.latitude = float(latitude)
    self.longitude = float(longitude)
    self.timeZone = float(timeZone)
    self.elevation = float(elevation)
    self.source = str(source)
    self.stationId = str(stationId)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.Location.createFromEPString">
    <p>def <span class="ident">createFromEPString</span>(</p><p>self, EPString)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a Ladybug location from an EnergyPlus location string
Parameters:
    EPString: Standard EP location string</p>
<p>Usage:
    l = Location() #initiate location
    l.createFromEPString(EPString)
    print "LAT:%s, LON:%s"%(l.latitude, l.longitude)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.Location.createFromEPString', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.Location.createFromEPString" class="source">
    <pre><code>def createFromEPString(self, EPString):
    """Create a Ladybug location from an EnergyPlus location string
        Parameters:
            EPString: Standard EP location string
        Usage:
            l = Location() #initiate location
            l.createFromEPString(EPString)
            print "LAT:%s, LON:%s"%(l.latitude, l.longitude)
    """
    try:
        self.city, self.latitude, \
        self.longitude, self.timeZone, \
        self.elevation = re.findall(r'\r*\n*([a-zA-Z0-9.:_-]*)[,|;]', \
                                EPString, re.DOTALL)[1:]
        self.latitude = float(self.latitude)
        self.longitude = float(self.longitude)
        self.timeZone = float(self.timeZone)
        self.elevation = float(self.elevation)
    except Exception, e:
        raise Exception ("Failed to import EP string! %s"%str(e))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ladybug.core.Location.duplicate">
    <p>def <span class="ident">duplicate</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ladybug.core.Location.duplicate', this);">Show source &equiv;</a></p>
  <div id="source-ladybug.core.Location.duplicate" class="source">
    <pre><code>def duplicate(self):
    return copy.deepcopy(self)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a>
    </p>
  </footer>
</div>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
